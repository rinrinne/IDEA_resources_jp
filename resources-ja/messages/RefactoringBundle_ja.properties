readonly.occurences.found=対象は読み取り専用ファイルで見つかりました
progress.text=使用箇所を検索しています...
usageView.tabText=リファクタリング プレビュー
usageView.usagesText=使用箇所
usageView.need.reRun=リファクタリング処理を実行できません。\n使用箇所が見つかった後にコードで変更されています。\n使用箇所を再検索してください。
usageView.doAction=リファクタリング実行(&D)
statusBar.refactoring.result={0, choice, 1\#1 occurence|2\#{0,number} occurences} が変更されました
statusBar.noUsages=対象が見つかりません
anonymousToInner.refactoring.name=匿名を内部に変換
anonymousToInner.no.inner.class.name=クラス名を指定してください
inner.class.exists=内部クラス ''{0}'' は既に\nクラス ''{1}'' で定義されています
anonymousToInner.class.name.label.text=クラス名 \:
anonymousToInner.make.class.static.checkbox.text=クラスを静的にする(&S)
anonymousToInner.parameters.panel.border.title=コンストラクタ パラメータ
error.wrong.caret.position.method=キャレットはリファクタリングするメソッドの内部で使用してください。
error.wrong.caret.position.constructor=キャレットはリファクタリングするコンストラクタの内部で使用してください。
error.wrong.caret.position.method.or.class.name=キャレットはリファクタリングするメソッドまたはクラスの名前で使用してください。
error.wrong.caret.position.method.or.variable.name=The caret should be positioned at the name of the method or variable to be refactored.
error.wrong.caret.position.anonymous=キャレットはリファクタリングする匿名クラスの内部で使用してください。
error.wrong.caret.position.class=キャレットはリファクタリングするクラスの内部で使用してください。
error.wrong.caret.position.method.or.local.name=キャレットはリファクタリングするメソッドまたはローカル変数の\n名前で使用してください。
error.wrong.caret.position.local.name=キャレットはリファクタリングするローカル変数の名前で使用してください。
error.wrong.caret.position.local.or.expression.name=The caret should be positioned at the name of the local variable or expression to be refactored.
error.wrong.caret.position.symbol.to.rename=The caret should be positioned at the symbol to be renamed.
error.wrong.caret.position.symbol.to.refactor=The caret should be positioned at the symbol to be refactored.
error.out.of.project.element=選択した {0} はプロジェクトの内部にありません。
error.in.injected.lang.prefix.suffix=Selected {0} is located in the readonly part of the injected language document.
error.cannot.be.renamed=This element cannot be renamed.
to.refactor=リファクタリングする
error.cannot.resolve={0} を解決できません
error.incorrect.data=不正なデータ
error.wrong.name.input=不正な名前 \: {0}
error.not.supported.for.jsp={0} のリファクタリングは JSP ではサポートされていません
changeClassSignature.refactoring.name=クラス シグネチャの変更
changeClassSignature.no.type.parameters=The class cannot have type parameters.
changeClassSignature.parameters.panel.border.title=パラメータ
changeClassSignature.bad.default.value=不正なデフォルト値 \: パラメータ {1} の ''{0}''
changeClassSignature.class.label.text={0} のシグネチャの変更
changeSignature.no.type.for.parameter=パラメータ ''{0}'' の型を指定する
changeSignature.no.type.for.exception=例外の型を指定する
changeSignature.refactoring.name=シグネチャの変更
column.name.name=名前
changeSignature.default.value.column=デフォルト値
parameters.border.title=パラメータ
changeSignature.exceptions.panel.border.title=例外
changeSignature.propagate.parameters.title=パラメータの伝播
changeSignature.propagate.exceptions.title=例外の伝播
changeSignature.parameter.caller.chooser=新規パラメータを伝播するメソッドの選択
changeSignature.exception.caller.chooser=新規例外を伝播するメソッドの選択
changeSignature.return.type.prompt=戻り型(&T)\:
changeSignature.name.prompt=&Name\:
name.prompt=名前(&N)\:
signature.preview.border.title=シグネチャ プレビュー
changeSignature.parameters.wont.propagate=パラメータ変更の再帰伝播は実行されません
changeSignature.exceptions.wont.propagate=例外変更の再帰伝播は実行されません
changeSignature.wrong.return.type=不正な戻り型 \: ''{0}''
changeSignature.no.return.type=戻り型を指定する
changeSignature.cannot.resolve.return.type=Return type ''{0}'' cannot be resolved.\nContinue?
changeSignature.wrong.type.for.parameter=不正な型 \: パラメータ {1} の ''{0}''
changeSignature.wrong.type.for.exception=不正な型 \: 例外の ''{0}''
changeSignature.vararg.not.last=vararg パラメータはメソッド シグネチャの最後になければなりません
changeSignature.no.default.value=新規パラメータ {0} が追加されました。\nこのメソッドのすべての既存の呼び出しで使用するデフォルト値を指定してください。
changeSignature.not.throwable.type=不正な型\: 例外の ''{0}''、java.lang.Throwable を拡張してください
changeSignature.cannot.resolve.parameter.type=Type ''{0}'' for parameter ''{1}'' cannot be resolved.\nContinue?
search.in.comments.and.strings=コメントと文字列内を検索(&S)
search.for.text.occurrences=Search for &text occurrences
visibility.as.is=そのまま(&A)
visibility.escalate=&Escalate
visibility.public=パブリック(&B)
visibility.protected=プロテクト(&O)
visibility.private=プライベート(&V)
visibility.package.local=パッケージ ローカル(&K)
visibility.border.title=可視性
visibility.combo.title=&Visibility\:
moveInstanceMethod.select.an.instance.parameter=インスタンス パラメータを選択(&S)\:
destination.package=パッケージ作成先(&D)\:
choose.destination.package=パッケージ作成先の選択
interface.name.prompt=インターフェイス名(&I)\:
package.for.new.interface=新規インターフェイスのパッケージ(&P)\:
turnRefsToSuper.change.usages.to={0} の使用箇所を変更(&C)\:
turnRefsToSuper.use.superclass.in.instanceof=instanceof でインターフェイス/スーパークラスを使用(&U)
class.name.prompt=クラス名(&N)\:
parameter.name.prompt=パラメータ名(&R)\:
no.class.name.specified=クラス名が指定されていません
no.parameter.name.specified=パラメータ名が指定されていません
pass.outer.class.instance.as.parameter=外部クラス インスタンスをパラメータとして渡す(&O)
pull.up.members.to={0} のメンバを引き上げる(&P)\:
members.to.be.pulled.up=引き上げるメンバ
make.abstract=抽象にする
javadoc.for.abstracts=抽象の JavaDoc
extractIncludeFile.name=インクルード ファイルの抽出
file.already.exist=File {0} already exists
file.already.exist.title=Extract Include File
name.for.extracted.include.file=抽出したインクルード ファイル名 (拡張子なし) (&N)\:
extract.to.directory=ディレクトリに抽出(&D)\:
select.target.directory=ターゲット ディレクトリの選択
select.target.directory.description=ファイルはこのディレクトリに作成されます
create.directory=ディレクトリの作成
replace.inheritance.from=委譲で継承を置換する(&R)\:
field.name=フィールド名(&F)\:
inner.class.name=内部クラス名(&I)\:
superclass.name=スーパークラス名(&S)\:
delegate.members=メンバの委譲
generate.getter.for.delegated.component=委譲したコンポーネントの getter を生成(&G)
package.for.new.superclass=新規スーパークラスのパッケージ(&P)\:
package.for.original.class=&Package for original class\:
package.for.original.interface=&Package for original interface\:
ExtractSuperClass.superclass=スーパークラス
members.to.form.superclass=スーパークラスを形成するメンバ
no.superclass.name.specified=スーパークラス名が指定されていません
extract.superclass.from=スーパークラスを抽出\:
extractSuper.extract={0} を抽出(&X)
extractSuper.rename.original.class=オリジナル クラス名を変更して可能な {0} を使用する(&E)
extractSuper.rename.original.class.to=オリジナル クラス名を変更(&R)\:
extractSuperInterface.interface=インターフェイス
members.to.form.interface=インターフェイスを形成するメンバ
extract.interface.from=インターフェイスを抽出\:
rename.implementation.class.to=実装クラス名を変更\:
rename.original.interface.to=Rename original interface to\:
extractSuperInterface.javadoc=JavaDoc
no.interface.name.specified=インターフェイス名が指定されていません
replace.all.occurences=すべて置換 ({0} 箇所) (&A)
declare.final=final の宣言(&F)
introduce.parameter.title=パラメータの導入
parameter.of.type=型のパラメータ(&T)\:
use.variable.initializer.to.initialize.parameter=パラメータの初期化に変数初期化子を使用する(&I)
replace.fields.used.in.expressions.with.their.getters=式で使用されているフィールドを getter で置換します
do.not.replace=置換しない(&N)
replace.fields.inaccessible.in.usage.context=コンテキストのアクセスできないフィールドを置換する(&I)
replace.all.fields=すべてのフィールドを置換(&R)
class.does.not.exist.in.the.project=クラスはプロジェクトに存在しません
no.field.name.specified=フィールド名が指定されていません
field.exists=名前 {0} のフィールドは\n既にクラス ''{1}'' に存在します。\n続行しますか ?
choose.destination.class=デスティネーション クラスの選択
replace.write.access.occurrences=書き込みアクセスを置換(&L)

# introduce variable
introduce.variable.title=変数の導入
refactoring.introduce.context.error=Cannot perform refactoring in this context
refactoring.introduceVariable=Extract Variable refactoring
refactoring.introduce.selection.error=Cannot perform refactoring using selected element(s)
refactoring.introduce.name.error=Incorrect name
refactoring.introduce.name.used.error=This name is already used
refactoring.introduce.variable.scope.error=Name clashes with existing variable
refactoring.introduce.placing.error=Cannot extract {0} variable

variable.of.type=型の変数(&T)\:
convert.to.instance.method.title=インスタンス メソッドに変換
convertToInstanceMethod.method.is.not.static=リファクタリングを実行できません。\nメソッド {0} は静的ではありません。
convertToInstanceMethod.no.parameters.with.reference.type=参照型を持つパラメータはありません。
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=すべての参照型パラメータは不明な型を持っています。
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=すべての参照型パラメータはプロジェクトにない型を持っています。
cannot.perform.refactoring=リファクタリングを実行できません。
move.instance.method.title=Move インスタンス メソッド
move.method.is.not.supported.for.constructors=Move メソッドはコンストラクタでサポートされていません
move.method.is.not.supported.for.generic.classes=Move メソッドはジェネリック クラスでサポートされていません
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=Move メソッドはメソッドが継承階層の一部である場合はサポートされていません
synthetic.jsp.class.is.referenced.in.the.method=Synthetic jsp クラスがメソッドで参照されています
there.are.no.variables.that.have.reference.type=参照型を持つ変数はありません。
all.candidate.variables.have.unknown.types=すべての候補変数は不明な型を持っています。
all.candidate.variables.have.types.not.in.project=すべての候補変数はプロジェクトにない型を持っています。
use.interface.where.possible.title=可能なインターフェイスの使用
interface.does.not.have.base.interfaces=インターフェイス {0} にベース インターフェイスはありません。
the.field.should.be.declared.in.a.class=フィールドをクラスで宣言してください。
encapsulate.fields.title=カプセル化フィールド
fields.to.be.refactored.should.belong.to.the.same.class=リファクタリングするフィールドは同じクラスに属している必要があります。
encapsulate.fields.refactoring.cannot.be.applied.to.interface=カプセル化フィールドのリファクタリングはインターフェイスには適用できません
extract.interface.title=インターフェイスの抽出
extract.interface.command.name={1} からインターフェイス {0} を抽出しています
extract.method.title=メソッドの抽出
selected.block.contains.invocation.of.another.class.constructor=選択したブロックは別のクラス コンストラクタの呼び出しを含んでいます。
selected.block.should.represent.a.set.of.statements.or.an.expression=選択したブロックは文または式のセットを表現しなければなりません。
press.escape.to.remove.the.highlighting=Esc キーで強調表示をクリアします
extract.superclass.title=スーパークラスの抽出
extract.superclass.command.name={1} からスーパークラス {0} を抽出しています
superclass.cannot.be.extracted.from.an.interface=スーパークラスはインターフェイスから抽出できません。
superclass.cannot.be.extracted.from.an.enum=スーパークラスは enum から抽出できません。
replace.inheritance.with.delegation.title=委譲で継承を置換する
class.is.interface={0} はインターフェイスです。
class.does.not.have.base.classes.or.interfaces=クラス {0} にベース クラスまたはインターフェイスはありません。
inline.title=インライン化
introduce.constant.title=定数の導入
introduce.selection.error=Cannot perform refactoring using selected element(s)
selected.expression.cannot.be.a.constant.initializer=選択した式は定数初期化子にできません。
variable.does.not.have.an.initializer=変数 {0} に初期化子はありません。
initializer.for.variable.cannot.be.a.constant.initializer=変数 {0} の初期化子は定数初期化子にできません。
cannot.introduce.field.in.interface=インターフェイスでフィールドを導入できません
introduce.field.title=フィールドの導入
selected.block.should.represent.an.expression=選択したブロックは式を表現しなければなりません。
is.not.supported.in.the.current.context={0} は現在のコンテキストではサポートされていません。
type.of.the.selected.expression.cannot.be.determined=選択した式の型は決定できません。
selected.expression.has.void.type=選択した式は void 型です。
to.rename=名前変更
to.delete.with.usage.search=削除 (使用箇所の検索)
unknown.expression.type=不明な式の型です。
invalid.expression.context=無効な式のコンテキストです。
refactoring.is.not.supported.in.the.current.context={0} のリファクタリングは現在のコンテキストではサポートされていません
cannot.introduce.variable.in.super.constructor.call=スーパー コンストラクタ呼び出しでは変数を導入できません
is.modified.in.loop.body={0} はループ ボディ内で変更されました。\n
introducing.variable.may.break.code.logic=変数の導入はコード ロジックを変更します。
no.selection=選択なし。
selection.does.not.form.a.fragment.for.extraction=選択は抽出のフラグメントを形成しません。
cannot.extract.selected.elements.into.include.file=選択した要素をインクルード ファイルに抽出できません。
the.language.for.selected.elements.has.no.associated.file.type=選択した要素の言語はファイル タイプと関連付けられていません
extract.include.file.title=インクルード ファイルの抽出
replace.fragment=フラグメントの置換
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0} に include ディレクティブと置換できるフラグメントがあります。\nレビューしますか ?
remove.duplicates.command=重複の削除
make.method.static.title=メソッドを静的にする
constructor.cannot.be.made.static=コンストラクタは静的にできません。
this.member.does.not.seem.to.belong.to.any.class=このメンバはどのクラスにも属していません。
member.is.already.static=メンバは既に静的です。
cannot.make.abstract.method.static=抽象メソッドは静的にできません。
inner.classes.cannot.have.static.members=内部クラスは静的メンバを持てません
pull.members.up.title=メンバの引き上げ
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=キャレットはメンバを引き上げるクラスの内部で使用してください。
class.does.not.have.base.classes.interfaces.in.current.project={0} は現在のプロジェクトにベース クラス/インターフェイスを持っていません。
pullUp.command=メンバを {0} から引き上げています
push.members.down.title=メンバの引き下げ
the.caret.should.be.positioned.inside.a.class.to.push.members.from=キャレットはメンバを引き下げるクラスの内部で使用してください。
move.title=Move
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=キャレットはリファクタリングするクラス、メソッドまたはフィールドで使用してください。
select.refactoring.title=リファクタリングの選択
what.would.you.like.to.do=何を行いますか ?
move.packages.to.another.package={0} パッケージを別のパッケージに移動する(&P)
move.package.to.another.package=パッケージ ''{0}'' を別のパッケージに移動する(&P)
move.directories.to.another.source.root={0} ディレクトリを別のソース ルートに移動する(&R)
move.directory.to.another.source.root=ディレクトリ {0} を別のソース ルートに移動する(&R)
move.inner.class.to.upper.level=内部クラス {0} を上位レベルに移動する(&I)
move.inner.class.to.another.class=内部クラス {0} を別のクラスに移動する(&M)
move.nonstatic.class.from.jsp.not.supported=Moving non-static classes from JSP page is not supported.
package.occurs.in.package.prefixes.of.the.following.source.folders.n=パッケージ {0} は次のソース フォルダのパッケージ接頭辞にあります \:\n
these.package.prefixes.will.be.changed=これらのパッケージ接頭辞は変更されます。
rename.title=名前の変更
rename.not.supported=Operation is not supported.
multiple.directories.correspond.to.package=複数のディレクトリがパッケージに対応しています。\n
directories.and.all.references.to.package.will.be.renamed=\n\nこれらのすべてのディレクトリ名とパッケージ\n{0}\nへのすべての参照名は変更されます。\n続行しますか ?
rename.package.button.text=Rename &package
rename.directory.button.text=Rename &directory
rename.directories=Rename &all
rename.current.directory=Rename &current
move.current.directory=Move &current
move.directories=Move &all
warning.title=警告
replace.constructor.with.factory.method.title=コンストラクタをファクトリ メソッドで置換
class.does.not.have.implicit.default.consructor=クラス {0} に暗黙的なデフォルト コンストラクタはありません。
would.you.like.to.replace.default.constructor.of.0.with.factory.method={0} のデフォルト コンストラクタをファクトリ メソッドで置換しますか ?
refactoring.is.not.supported.for.local.and.jsp.classes=リファクタリングはローカルおよび JSP クラスでサポートされていません。
refactoring.is.not.supported.for.jsp.classes=Refactoring is not supported for JSP classes.
class.is.abstract={0} は抽象です。
method.is.not.a.constructor=メソッドはコンストラクタではありません。
safe.delete.title=セーフ デリート
replace.temp.with.query.title=temp をクエリーで置換
cannot.replace.temp.with.query.in.interface=インターフェイスで temp をクエリーに置換できません。
variable.has.no.initializer=変数 {0} に初期化子はありません。
variable.has.no.dominating.definition=Cannot find a single definition to inline.
variable.is.never.used=変数 {0} は使用されません。
variable.is.accessed.for.writing=変数 {0} は書き込み用にアクセスされます。
variable.is.accessed.for.writing.and.used.with.inlined=Another variable ''{0}'' definition is used together with inlined one.
only.fields.variables.of.methods.of.valid.type.can.be.considered=有効な型のメソッドのフィールド、変数のみ考慮できます。
unable.to.start.type.migration=型の移行を開始できません
replace.method.code.duplicates.title=メソッド コードの重複の置換
locate.caret.inside.a.method=キャレットをメソッドの内部に移動します。
replace.with.method.call.does.not.work.for.constructors=メソッド呼び出しの置換はコンストラクタでは動作しません
method.does.not.have.a.body=メソッド {0} にボディはありません。
method.has.an.empty.body=メソッド {0} のボディは空です。
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} にメソッド呼び出しと置換できるコードはありません
method.duplicates.found.message={0, choice, 1\#1 code fragment|2\#{0,number} code fragments} が見つかりました
0.with.1.visibility.is.not.accessible.from.2={0} with {1} visibility won''t be accessible from {2}
0.contains.call.with.null.argument.for.parameter.1={0} はパラメータ {1} の null 引数を持つ呼び出しを含んでいます
no.members.selected=メンバが選択されていません
0.already.exists.in.the.target.class={0} は既にターゲット クラスに存在します。
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} は {1} で、ターゲット クラスで {2} からアクセスできません
renamed.class.will.hide.0.in.1=名前変更されたクラスは {1} の {0} を非表示にします
there.is.already.a.0.it.will.conflict.with.the.renamed.1=既に {0} があります。 名前変更された {1} と競合します
0.will.override.renamed.1={0} は名前変更された {1} をオーバーライドします
0.will.hide.renamed.1={0} は名前変更された {1} を非表示にします
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter=既に {1} に {0} があります。 名前変更されたパラメータと競合します。
do.you.want.to.process.overriding.methods.with.covariant.return.type=共変の戻り型でメソッドのオーバーライドを\n処理しますか ?
changing.signature.of.0={0} のシグネチャを変更しています
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter=既に {1} に {0} があります。 新規パラメータと競合します。
0.to.change.signature=シグネチャを変更する {0}
New.name.of.method.is.not.java.identifier=New name of method is not Java identifier
references.to.be.changed=変更された {0} となる参照
source.folder.0.has.package.prefix.1=ソース フォルダ {0} のパッケージ接頭辞が ''{1}'' です。\nパッケージ ''{2}'' はそこでは作成できません。
javadoc.as.is=そのまま(&A)
javadoc.copy=コピー(&C)
javadoc.move=移動(&M)
replace.instance.qualifiers.with.class.references=インスタンス限定子をクラス参照で置換する
make.0.static={0} を静的にする
0.already.has.parameter.named.1.use.this.name.anyway={0} のパラメータ名は ''{1}'' に変更されています。\nこの名前を使用しますか ?
this.method=このメソッド
add.object.as.a.parameter.with.name=名前のパラメータとしてオブジェクトを追加する(&O)\:
add.object.as.a.parameter.to.constructors.with.name=名前のコンストラクタへのパラメータとしてオブジェクトを追加する(&O)\:
add.parameters.for.fields=フィールドのパラメータを追加する(&F)\:
add.parameters.for.fields.to.constructors=コンストラクタへのフィールドのパラメータを追加する(&F)\:
0.already.contains.field.1={0} は既にフィールド {1} を含んでいます。
0.is.already.overridden.in.1={0} は既に {1} でオーバーライドされています。 メソッドはそのクラスに引き下げられません。
0.already.contains.inner.class.named.1={0} は既に内部クラス {1} を含んでいます。
0.uses.1.which.is.pushed.down={0} は引き下げられる {1} を使用します
refactoring.cannot.be.performed=リファクタリングは実行できません
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=既に {0} があります。 導入したパラメータと競合します
introduce.parameter.command={0} にパラメータを導入しています
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=パラメータ初期化子は {0} を含んでいますが、メソッドへの呼び出しはクラスにありません。
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} is not accessible from {1}. Value for introduced parameter in that method call will be incorrect.
use.interface.superclass.in.instanceof=instanceof でインターフェイス/スーパークラスを使用
introduce.parameter.to.method=メソッドへのパラメータの導入 \:
introduced.variable.will.conflict.with.0=導入した変数は {0} と競合します
column.name.type=型
column.name.any.var=任意の変数
column.name.default.value=デフォルト値
caller.chooser.caller.method=呼び出し元メソッド
caller.chooser.callee.method=呼び出し先メソッド
caller.chooser.looking.for.callers=呼び出し元を検索しています...
copy.class.clone.0.1={0} {1} のクローン
copy.class.copy.0.1={0} {1} のコピー
invalid.target.package.name.specified=無効なターゲット パッケージ名が指定されています
invalid.target.package.name.default.package=Cannot move classes to default package
error.title=エラー
cannot.create.directory=ディレクトリを作成できません
no.target.directory.specified=ターゲット ディレクトリが指定されていません
copy.files.new.name.label=新しい名前 \:
no.new.name.specified=新しい名前が指定されていません
copy.files.copy.specified.files.label=指定したファイルをコピーする
copy.files.copy.specified.directories.label=指定したディレクトリをコピーする
copy.files.copy.specified.mixed.label=Copy specified files and directories
copy.files.to.directory.label=ディレクトリ\:
the.file.will.be.copied.to.this.directory=ファイルはこのディレクトリにコピーされます
copy.files.clone.title=クローン
copy.files.copy.title=コピー
copy.files.clone.file.0=ファイル {0} のクローン
copy.files.copy.file.0=ファイル {0} のコピー
copy.files.clone.directory.0=ディレクトリ {0} のクローン
copy.files.copy.directory.0=ディレクトリ {0} のコピー
copy.handler.copy.class=クラスのコピー
copy.handler.clone.class=クラスのクローン
copy,handler.clone.files.directories=ファイル/ディレクトリのクローン
copy.handler.copy.files.directories=ファイル/ディレクトリのコピー
encapsulate.fields.get.access.checkbox=get アクセス(&G)
encapsulate.fields.set.access.checkbox=set アクセス(&S)
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=フィールドがアクセス可能なときもアクセッサを使用(&U)
encapsulate.fields.private.radio=プライベート(&I)
encapsulate.fields.protected.radio=プロテクト(&T)
encapsulate.fields..package.local.radio=パッケージ ローカル(&C)
encapsulate.fields.encapsulate.border.title=カプセル化
encapsulate.fields.options.border.title=オプション
encapsulate.fields..encapsulated.fields.visibility.border.title=カプセル化したフィールドの可視性
encapsulate.fields.accessors.visibility.border.title=アクセスの可視性
encapsulate.fields.fields.to.encapsulate.border.title=カプセル化するフィールド
encapsulate.fields.field.column.name=フィールド
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.no.fields.selected=フィールドが選択されていません
encapsulate.fields.command.name={0} でフィールドをカプセル化しています
encapsulate.fields.getter.exists=既に戻り型のみ getter {1} と異なるメソッド {0} があります。
encapsulate.fields.setter.exists=既に戻り型のみ setter {1} と異なるメソッド {0} があります。
encapsulate.fields.fields.to.be.encapsulated=カプセル化するフィールド
invocations.to.be.inlined=インライン化する呼び出し {0}
classes.to.push.down.members.to={0} にメンバを引き下げるクラス
references.in.code.to.elements.from.migration.map=移行マップ "{0}" から要素へのコードの参照 {1}
press.the.do.migrate.button=移行マップ "{0}" を使用して移行するには\n検索結果パネルの下にある "移行" ボタンを押します\n
declaration.s.to.be.generified=一般化された {0} となる宣言
occurences.to.be.migrated=移行された {0} となる対象
references.in.code=コード {0} の参照
safe.delete.comment.occurences.header=対象はコメント、文字列および非 java ファイル {0} で見つかりました。 これらの対象は変更されません
move.single.element.elements.header={1} に移動する {0}
references.in.code.to.0.1={0} {1} へのコードの参照
move.classes.elements.header={0} に移動するクラス
move.packages.elements.header={0} に移動するパッケージ
references.found.in.code=コードで見つかった参照
comments.elements.header=対象はコメント、文字列および非 java ファイル {0} で見つかりました
move.files.elements.header={0} に移動するファイル
move.directories.elements.header={0} に移動するディレクトリ
make.static.description.label={0} {1} を静的にする
there.is.already.a.0.in.1=既に {1} に {0} があります
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} は、パラメータとして渡されない静的でない {1} を使用します
0.uses.1.which.needs.class.instance={0} は、クラス インターフェイスが必要な {1} を使用します。
method.0.is.overridden.by.1=メソッド {0} は {1} でオーバーライドされます。
make.static.command={0} を静的にしています
introduce.parameter.elements.header=メソッドにパラメータを追加しています
annotate.field.as.nonnls.checkbox=@NonNls としてフィールドを注釈する
replace.all.occurences.checkbox=すべて置換(&A)
introduce.constant.introduce.to.class=クラスに導入 (完全修飾名)\:
introduce.field.static.field.of.type=型の静的フィールド(&T)\:
introduce.field.field.of.type=型のフィールド(&T)\:
replace.all.occurrences.of.expression.0.occurrences=式のすべての置換 ({0} 箇所) (&A)
delete.variable.declaration=変数宣言の削除(&D)
initialize.in.border.title=初期化
setup.method.radio=setUp メソッド(&S)
current.method.radio=現在のメソッド
field.declaration.radio=フィールド宣言(&D)
class.constructors.radio=クラス コンストラクタ(&C)
convert.local.to.field.title=フィールドにローカルを変換
introduce.constant.field.of.type=型の定数 (static final フィールド) (&T)\:
extract.subclass.command=サブクラスの抽出
extract.superclass.elements.header=ディレクトリへのメンバでスーパークラスを抽出
declare.static.checkbox=static 宣言(&S)
declare.varargs.checkbox=Declare v&arargs
declare.folded.parameters=&Fold parameters
extract.method.method.panel.border=メソッド
there.are.multiple.exit.points.in.the.selected.code.fragment=選択したコード フラグメントに複数の終了ポイントがあります
move.members.elements.header=移動するメンバ
move.members.move.members.from.label=メンバの移動元\:
move.members.to.fully.qualified.name.label=移動先 (完全修飾名)\:
move.members.members.to.be.moved.border.title=移動するメンバ (static のみ)
no.destination.class.specified=デスティネーション クラスが指定されていません
0.is.not.a.legal.fq.name=''{0}'' は正式な FQ 名ではありません
create.class.command=クラス {0} の作成
source.and.destination.classes.should.be.different=ソース クラスとデスティネーション クラスが同じです
cannot.move.inner.class.0.into.itself=内部クラス {0} を自身に移動できません。
class.0.does.not.exist=クラス {0} は存在しません。\n作成しますか ?
move.members.title=メンバの移動
members.to.be.moved.should.belong.to.the.same.class=移動するメンバは同じクラスに属している必要があります。
field.0.is.not.static=フィールド {0} は静的ではありません。\n{1} のリファクタリングは静的メンバのみではサポートされていません。
0.refactoring.cannot.be.applied.to.constructors={0} のリファクタリングはコンストラクタには適用できません
method.0.is.not.static=メソッド {0} は静的ではありません。\n{1} のリファクタリングは静的メンバのみではサポートされていません。
inner.class.0.is.not.static=内部クラス {0} は静的ではありません。\n{1} のリファクタリングは静的メンバのみではサポートされていません。
inline.field.title=フィールドのインライン化
0.refactoring.is.supported.only.for.final.fields={0} のリファクタリングは final フィールドではサポートされていません
no.initializer.present.for.the.field=そのフィールドの初期化子は存在しません
field.0.is.never.used=フィールド {0} は使用されません
inline.field.command=フィールド {0} をインライン化する
0.is.used.for.writing.in.1={0} は {1} で書き込みに使用されています
0.will.not.be.accessible.from.1.after.inlining={0} はインライン化の後は {1} からアクセスできません
inline.field.field.name.label=フィールド {0}
inline.field.border.title=インライン化
all.references.and.remove.the.field=すべての参照。フィールドを削除(&A)
this.reference.only.and.keep.the.field=この参照のみ。フィールドを保持(&T)
inline.variable.title=変数のインライン化
variable.is.referenced.in.multiple.files=変数 {0} は複数のファイルで参照されます
variable.is.never.used.before.modification=変数 {0} は変更前に使用されません
inline.command=Inline {0}
inline.local.variable.prompt=ローカル変数 {0} をインライン化しますか ?
inline.local.variable.definition.prompt=Inline local variable ''{0}'' definition?
occurences.string=({0,choice,1\#1 occurence|2\#{0,number} occurences})
inline.method.title=メソッドのインライン化
inline.method.method.label=メソッド {0}
inline.method.border.title=インライン化
all.invocations.and.remove.the.method=すべての呼び出し。メソッドを削除(&A)
all.invocations.in.project=プロジェクトのすべての呼び出し(&A)
this.invocation.only.and.keep.the.method=この呼び出しのみ。メソッドを保持(&T)
refactoring.cannot.be.applied.to.abstract.methods={0} のリファクタリングは抽象メソッドには適用できません
refactoring.cannot.be.applied.no.sources.attached={0} のリファクタリングは適用できません \: ソースがアタッチされていません
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow={0} のリファクタリングは return 文が実行フローを中断する場合はサポートされていません
refactoring.is.not.supported.for.recursive.methods={0} のリファクタリングは再帰メソッドではサポートされていません
refactoring.cannot.be.applied.to.vararg.constructors={0} リファクタリングは vararg コンストラクタには適用できません
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} リファクタリングはインラインの非チェーン コンストラクタには適用できません
inline.method.command=メソッド {0} をインライン化しています
inlined.method.implements.method.from.0=インライン化したメソッドは {0} からのメソッドを実装します
inlined.method.overrides.method.from.0=インライン化したメソッドは {0} からのメソッドをオーバーライドします
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1=インライン化したメソッドで使用される {0} は {1} のコールサイトからアクセスできません
inline.method.elements.header=インライン化するメソッド
inline.field.elements.header=インライン化するフィールド
inline.class.elements.header=Class to inline
inline.vars.elements.header=Variable to inline
interface.has.been.successfully.created=インターフェイス {0} は正常に作成されました
class.has.been.successfully.created=クラス {0} は正常に作成されました
use.super.references.prompt=このステージで、{0} は {1} の使用箇所を分析して\n可能な場所で {2} の使用箇所と置換できます。\n続行しますか ?
analyze.and.replace.usages=使用箇所の分析と置換
there.are.multiple.output.values.for.the.selected.code.fragment=選択したコード フラグメントに複数の出力値があります \:
expression.result=式の結果
boolean.method.result=boolean method result
instances.of.0.upcasted.to.1.were.found={1} にアップキャストされた {0} のインスタンスが見つかりました。 続行すると、別の [検索] タブに表示されます。
0.uses.1.of.an.instance.of.a.2={0} じゃ {2} のインスタンスの {1} を使用します。
0.upcasts.an.instance.of.1.to.2={0} は {1} のインスタンスを {2} にアップキャストします。
0.will.no.longer.override.1={0} は {1} をオーバーライドしません
replacing.inheritance.with.delegation=委譲で継承を置換しています
instances.casted.to.java.lang.object=java.lang.Object にキャストされたインスタンス
instances.upcasted.to.object=オブジェクトにアップキャストされたインスタンス
instances.upcasted.to.java.lang.object.found=java.lang.Object にアップキャストされたインスタンスが見つかりました
replace.inheritance.with.delegation.command={0} の委譲で継承を置換しています
replace.inheritance.with.delegation.elements.header=委譲で継承を置換します
# Inline included file
inline.included.file.title=インクルード ファイルのインライン化
the.caret.should.be.positioned.on.the.included.file.to.inline=The caret should be positioned on the included file reference to inline

inline.the.contents.include.prompt=''{0}'' の内容をインライン化しますか ?
remove.include.prompt=インクルード ファイルはもう使用されません。 削除しますか ?
delete.include.command={0} の削除
make.static.elements.header={0} を静的にする
field.0.is.not.accessible=フィールド {0} は {1} からアクセスできません
fields.0.are.not.accessible=フィールド {0} は {1} からアクセスできません
0.is.not.static.it.cannot.be.moved.to.the.interface={0} は静的ではありません。  それはインターフェイスに移動できません
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} は宣言で初期化されていません。 これらのフィールドはインターフェイスで使用できません。
0.already.contains.a.1={0} は既に {1} を含んでいます
0.uses.1.which.is.not.accessible.from.the.superclass={0} はスーパークラスからアクセスできない {1} を使用します
0.uses.1.which.is.not.moved.to.the.superclass={0} はスーパークラスに移動できない {1} を使用します
push.members.from.0.down.label={0} からのメンバを引き下げる
members.to.be.pushed.down.panel.title=引き下げられるメンバ
keep.abstract.column.header=抽象を保持する
push.down.javadoc.panel.title=抽象の JavaDoc
push.down.members.elements.header=メンバを引き下げる
interface.0.does.not.have.inheritors=インターフェイス {0} には継承はありません。
class.0.does.not.have.inheritors=クラス {0} には継承はありません。
push.down.will.delete.members=メンバを引き下げるとメンバは削除されます。 続行しますか ?
edit.migration.map.title=移行マップの編集
migration.map.name.prompt=マップ名 \:
migration.map.description.label=マップの説明 \:
migration.add.button=追加...
migration.edit.button=編集...
migration.remove.button=削除
migration.move.up.button=上へ移動
migration.move.down.button=下へ移動
migration.type.column.header=型
migration.old.name.column.header=古い名前
migration.new.name.column.header=新しい名前
migration.package.with.subpackages=サブパッケージを含むパッケージ
migration.package=パッケージ
migration.class=クラス
edit.migration.entry.title=クラス/パッケージ移行説明の編集
migration.entry.package=パッケージ
migration.entry.class=クラス
migration.entry.old.name=古い名前 \:
migration.entry.new.name=新しい名前 \:
select.migration.map=移行マップの選択 \:
migration.new.button=新規...
migration.dialog.title=パッケージとクラスの移行
migration.dialog.ok.button.text=実行
migration.map.set.migration.maps=移行マップ
migration.no.usages.found.in.the.project=プロジェクトで使用箇所は見つかりません
migration.title=移行
move.classes.move.to.another.source.folder=Move to another source &folder
move.specified.classes=指定されたクラスの移動
move.specified.packages=指定されたパッケージの移動
move.single.class.or.package.name.label={0} {1} の移動
please.enter.a.valid.target.package.name=有効なターゲット パッケージ名を入力してください
package.does.not.exist=パッケージ {0} は存在しません。\n作成しますか ?
move.package.refactoring.cannot.be.applied.to.default.package=Move Package リファクタリングはデフォルト パッケージに適用できません
move.class.refactoring.cannot.be.applied.to.anonymous.classes=Move Class リファクタリングは匿名クラスに適用できません
moving.local.classes.is.not.supported=ローカル クラスの移動はサポートされていません。
there.are.going.to.be.multiple.destination.files.with.the.same.name=同じ名前の複数のデスティネーション ファイルがあります。
do.you.wish.to.continue=続行しますか ?
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=これらのすべてのディレクトリは移動され、{0} へのすべての参照は\n変更されます。
select.source.root.chooser.title=ソース ルートを選択してください
moving.directories.command=ディレクトリを移動しています
0.uses.a.package.local.1={0} はパッケージ ローカル {1} を使用します。
a.package.local.class.0.will.no.longer.be.accessible.from.1=パッケージ ローカル クラス {0} はもう {1} からアクセスできません
element.will.no.longer.be.accessible={0} will no longer be accessible from {1}
move.instance.method.command=Move Instance メソッド
move.instance.method.elements.header=Move Instance メソッド
move.method.this.parameter.label=''{0}.this'' パラメータの名前を選択してください
move.method.enter.a.valid.name.for.parameter=パラメータの有効な名前を入力してください
0.is.an.interface.that.has.no.implementing.classes={0} はインターフェイスです。 \n実装するクラスはありません。
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} はインターフェイスです。 \nメソッドの実装はすべての直接実装するクラスに追加されます。\n実行しますか ?
move.inner.to.upper.level.title=内部クラスの上位レベルへの移動
move.inner.class.command=内部クラス {0} を移動しています
0.will.become.inaccessible.from.1={0} は {1} からアクセスできなくなります。
move.specified.files=指定されたファイルの移動
move.specified.directories=指定されたディレクトリの移動
move.file.0=ファイル {0} の移動
move.directory.0=ディレクトリ {0} の移動
move.files.to.directory.label=ディレクトリ\:
the.file.will.be.moved.to.this.directory=ファイルはこのディレクトリに移動されます
searching.for.variables=変数を検索しています
no.usages.can.be.replaced={0} の使用箇所は\n{1} の使用箇所で置換できません
turn.refs.to.super.command={0} の使用箇所を {1} で置換しています
references.to.0.to.be.replaced.with.references.to.1=''{0}'' への参照は ''{1}'' への参照で置換されます
factory.method.name.label=ファクトリ メソッド名 \:
replace.constructor.with.factory.target.fq.name=In (完全修飾名)\:
class.0.not.found=クラス {0} が見つかりません。
class.0.is.not.accessible.from.target.1=クラス {0} はターゲット {1} からアクセスできません。
target.0.is.not.accessible.from.1=ターゲット {0} は {1} からアクセスできません。
constructor.being.refactored.is.used.in.initializer.of.0=リファクタリングするコンストラクタは {0} の初期化子で使用されています。 内部クラス {1} の非静的ファクトリはこのコンテキストで使用できません。 生成されるコードはコンパイルしません。
replace.constructor.0.with.a.factory.method=コンストラクタ {0} をファクトリ メソッドで置換します
replace.default.constructor.of.0.with.a.factory.method={0} のデフォルト コンストラクタをファクトリ メソッドで置換します
replace.constructor.with.factory.method=コンストラクタをファクトリ メソッドで置換します
replace.default.constructor.with.factory.method=デフォルト コンストラクタをファクトリ メソッドで置換します
occurrences.found.in.comments.strings.and.non.java.files=対象はコメント、文字列および非 java ファイルで見つかりました
0.referenced.in.1.will.not.be.accessible.in.module.2={0}、{1} の参照はモジュール {2} でアクセスできません
0.referenced.in.1.will.not.be.accessible.from.module.2={0}、{1} の参照はモジュール {2} からアクセスできません
0.referenced.in.1.will.not.be.accessible.from.production.of.module.2={0}, referenced in {1}, will not be accessible from the production sources of module {2}
choose.destination.directory=作成先ディレクトリの選択
directory.chooser.hide.non.existent.checkBox.text=&Hide non-existent
0.will.be.inaccessible.from.1={0} は {1} からアクセスできなくなります
move.classes.command={0} を移動しています
safe.delete.command={0} を削除しています
select.all.button=すべて選択(&S)
unselect.all.button=すべて選択解除(&U)
automatic.renamer.enity.name.column={0} 名前
automatic.renamer.rename.to.column=名前変更
rename.0.and.its.usages.to={0} とその使用箇所の名前を変更する \:
rename.variables=変数名の変更(&V)
rename.inheritors=継承名の変更(&I)
rename.tests=Rename t&ests
rename.parameters.hierarchy=Rename parameters in hier&archy
rename.bound.forms=結合フォーム名の変更(&F)
inner.class.0.is.already.defined.in.class.1=内部クラス {0} は既にクラス {1} で定義されています。\n続行しますか ?
class.0.already.exists=クラス {0} は既に存在します
renaming.something=名前を変更しています
renaming.0.1.to.2={0} {1} の名前を {2} に変更しています
renaming.command.name=Renaming {0}
0.to.be.renamed.to.1.2={0} は {1}{2} に名前変更されます
references.in.code.to.0={0} へのコードの参照
rename.variables.title=変数名の変更
rename.variables.with.the.following.names.to=次の名前を含む変数の名前を変更します \:
entity.name.variable=変数
rename.bound.forms.title=結合フォーム名の変更
rename.forms.with.the.following.names.to=次の名前を含むフォームの名前を変更します \:
entity.name.form=フォーム
rename.inheritors.title=継承名の変更
rename.tests.title=Rename Tests
rename.inheritors.with.the.following.names.to=次の名前を含む継承の名前を変更します \:
rename.tests.with.the.following.names.to=Rename tests with the following names to\:
entity.name.inheritor=継承
entity.name.test=Test
unused.overriding.methods.title=未使用のオーバーライド メソッド
there.are.unused.methods.that.override.methods.you.delete=削除するメソッドをオーバーライドしている未使用のメソッドがあります。
choose.the.ones.you.want.to.be.deleted=削除するメソッドを選択してください。
method.column=メソッド
0.implements.1={0} は {1} を実装します。
attempting.to.delete.targets.node.text=削除を試行しています
retry.command=再試行
rerun.safe.delete=セーフ デリートの再実行
delete.title=削除
items.to.be.deleted=削除する項目
usages.detected=検出された使用箇所
delete.anyway.button=&Delete Anyway
ignore.button=無視
the.following.problems.were.found=次の問題が見つかりました \:
cancel.button=キャンセル
view.usages=使用箇所の表示
anonymous.class.text=匿名クラス
problems.detected.title=検出された問題
continue.button=続行
do.you.wish.to.ignore.them.and.continue=これらを無視して続行しますか ?
delegation.panel.method.calls.label=メソッド呼び出し \:
delegation.panel.modify.radio=変更(&M)
delegation.panel.delegate.via.overloading.method=オーバーロード メソッドによる委譲(&L)
information.title=情報
ok.button=OK
do.not.show.this.message.in.the.future=次回からこのメッセージを表示しない(&D)
member.column=メンバ
refactor.button=リファクタリング(&R)
preview.button=プレビュー(&P)
yes.button=はい(&Y)
no.button=いいえ(&N)
preview.usages.to.be.changed=変更される使用箇所のプレビュー(&P)
replace.this.code.fragment=このコード フラグメントを置換しますか ?
replace.this.code.fragment.and.make.method.static=(Method will be made static)
replace.this.code.fragment.and.make.method.static.visible=(Method will be made static and {0})
replace.this.code.fragment.and.make.method.visible=(Method will be made {0})
replace.this.code.fragment.and.change.signature=\nMethod signature will be changed to \n{0}
process.duplicates.title=プロセスの複製
process.methods.duplicates.title=Process Method {2} Duplicate ({0} of {1})
0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.method={0} は抽出したメソッドへの呼び出しと置換できるこのファイルの {1} コード フラグメントを検出しました。 レビューして置換しますか ?
replace.button=置換
method.duplicates.method.label=メソッド {0}
usages.detected.title=検出された使用箇所
generify.title=一般化
interface.member.dependency.required.by.interfaces={0,choice,1\#interface|2\#interfaces} で必要
member.info.implements.0=実装 {0}
member.info.extends.0=拡張 {0}
used.by.0={0} で使用
uses.0=使用 {0}
field.description=フィールド {0}
constructor.description=コンストラクタ {0}
method.description=メソッド {0}
parameter.description=パラメータ {0}
local.variable.description=ローカル変数 {0}
package.description=パッケージ {0}
class.description=クラス {0}
static.initializer.description=クラス {0} の静的初期化子
instance.initializer.description=クラス {0} のインスタンス初期化子
file.description=ファイル {0}
directory.description=ディレクトリ {0}
0.is.located.in.a.jar.file={0} は jar ファイルにあります。\n
0.is.read.only={0} は読み取り専用です。\n
0.is.not.a.legal.java.identifier=''{0}'' は正式な java 識別子ではありません
method.0.is.already.defined.in.the.1=メソッド {0} は既に {1} で定義されています。
method.0.will.hide.method.of.the.base.class=メソッド {0} はベース クラス {1} の\nメソッドを非表示にします。
method.0.will.implement.method.of.the.base.class=メソッド {0} はベース クラス {1} の\nメソッドを実装します。
method.0.will.override.a.method.of.the.base.class=メソッド {0} はベース クラス {1} の\nメソッドをオーバーライドします。
current.class=現在のクラス
field.0.is.already.defined.in.the.1=フィールド {0} は既に {1} で定義されています。
field.0.will.hide.field.1.of.the.base.class=フィールド {0} は\nベース クラス {2} のフィールド {1} を非表示にします。
directory.0.already.contains.1.named.2=ディレクトリ {0}\nには既に名前 ''{2}'' の {1} があります
directory.0.already.contains.a.file.named.1=ディレクトリ {0}\nには既に名前 ''{1}'' のファイルがあります
getter.and.setter.methods.found.for.the.field.0=フィールド {0} の getter と setter メソッドが見つかりました。 \nこれらも {1} しますか?
getter.method.found.for.the.field.0=フィールド {0} の getter メソッドが見つかりました。 \ngetter も {1} しますか?
setter.method.found.for.the.field.0=フィールド {0} の setter メソッドが見つかりました。 \nsetter も {1} しますか?
0.has.1.usages.in.comments.and.strings={0} has {1,choice,1\#1 usage|2\#{1,number} usages} in strings, comments, or non-Java files.
0.has.1.usages.that.are.not.safe.to.delete.of.those.2={0} has {1,choice,1\#1 usage that is|2\#{1,number} usages that are} not safe to delete.\nOf those {2,choice,1\#1 usage is|2\#{2,number} usages are} in strings, comments, or non-Java files.
type.cook.drop.obsolete.casts=以前のキャストをドロップ(&D)
type.cook.preserve.raw.arrays=raw 配列を維持(&A)
type.cook.leave.object.parameterized.types.raw=オブジェクトのパラメータ化された型を raw で残す(&L)
type.cook.perform.exhaustive.search=全数検索の実行(&E)
type.cook.generify.objects=オブジェクトの一般化(&O)
type.cook.produce.wildcard.types=ワイルドカード型の生成(&W)
type.cook.command=一般化
type.cook.elements.header=一般化するスコープ
type.cook.report=項目の一般化 \: {0}、キャストの削除 \: {1}
type.cook.ratio.generified={0,choice,-1\#not calculated|0\#{0,number} of {1}}
extract.method.control.flow.analysis.failed=コードに構文エラーがあります。 必要な分析を実行できません。
pushed.members.will.not.be.visible.from.certain.call.sites=Pushed members will not be visible from certain call sites.
invert.boolean.title=Invert Boolean
invert.boolean.wrong.type=Return type of the method or type of the variable to be refactored should be boolean
invert.boolean.refs.to.invert=References to be inverted {0}
invert.boolean.elements.header={0} to invert
please.enter.a.valid.name.for.inverted.element=Please enter a valid name for inverted {0}
invert.boolean.name.of.inverted.element=&Name of inverted {0}\:
invert.0.1=Invert {0} {1} and its usages
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} is a part of method hierarchy. Do you want to delete multiple parameters?
move.inner.class.to.be.moved=Class to be moved
move.specified.classes.to=Move specified classes to\:
destination.directory.does.not.correspond.to.any.package=The destination directory does not correspond to any package
cannot.find.or.create.destination.directory=Cannot find or create destination directory
cannot.move=Cannot Move
cannot.move.package.into.itself=Cannot move package into itself
rename.constructor.parameters.title=Rename Constructor Parameters
rename.constructor.parameters.with.the.following.names.to=Rename parameters with the following names to\:
entity.name.constructor.parameter=Parameter
replace.method.duplicates.scope.chooser.title=Specify {0} Scope
replace.method.duplicates.scope.chooser.message=Analysis scope
remove.parameter.0.no.longer.used=Remove parameter ''{0}'' no longer used
inline.to.anonymous.refactoring=Inline to Anonymous Class
inline.to.anonymous.no.abstract=Abstract classes cannot be inlined
inline.to.anonymous.no.inheritors=Classes which have subclasses cannot be inlined
inline.to.anonymous.no.multiple.interfaces=Classes which implement multiple interfaces cannot be inlined
inline.to.anonymous.no.superclass.and.interface=Classes which have a superclass and implement an interface cannot be inlined
move.class.to.inner.command.name=Move {0} to {1}
move.classes.destination.to.package=To packa&ge
move.classes.destination.make.inner=&Make inner class of
move.to.inner.duplicate.inner.class=Class {0} already contains an inner class named {1}
inline.to.anonymous.command.name=Inline class {0}
class.is.never.used=Class is never used
all.references.and.remove.the.class=Inline &all references and remove the class
this.reference.only.and.keep.the.class=Inline this reference only and &keep the class
inline.to.anonymous.name.label=Class {0}
inline.to.anonymous.border.title=Inline
move.class.to.inner.nonstatic.error=It is not allowed to move a class into a non-static inner class
move.class.to.inner.move.to.self.error=It is not allowed to move a class into itself
unsupported.refs.found=Unsupported references found in {0} files
inline.method.checking.tail.calls.progress=Checking tail call usages
extract.chained.constructor.checkbox=Extract &chained constructor
inline.parameter.refactoring=Inline Parameter
inline.parameter.confirmation=Inline parameter ''{0}'' with initializer ''{1}''?
inline.parameter.command.name=Inline Parameter {0}
inline.parameter.error.hierarchy=Inline parameter is not supported when method is a part of inheritance hierarchy
inline.parameter.error.varargs=Inline for varargs parameters is not supported
inline.parameter.replace.with.local.checkbox=R&eplace with local variable
type.migration.rerun.button.text=&Rerun Type Migration
type.migration.migrate.button.text=&Migrate
type.migration.exclude.action.text=&Exclude
type.migration.include.action.text=&Include
introduce.constant.enum.cb=Extract as &enum constant
move.enum.constant.cb=Move as &enum constants if possible
move.to.different.language=Target class {2} has different language than {0} {1}
dont.support.inner.classes=Refactoring ''Make inner class of'' is not available in {0}
move.specified.elements=Move specified elements
rename.directory.title=Rename &Directory
rename.module.title=Rename &Module

# extract method
refactoring.extract.method.dialog.title=Extract Method
refactoring.extract.method.dialog.method.name=Method name\:
refactoring.extract.method.dialog.parameters=Parameters
refactoring.extract.method.dialog.output.variables=Output variables
refactoring.extract.method.dialog.signature.preview=Signature preview
refactoring.extract.method.dialog.empty=Empty
change.signature.leave.blank.default.value=Leave &blank
change.signature.feel.lucky=Feel &lucky
change.signature.use.selected.value=Use selected &value

search.for.references=Search for re&ferences
0.is.not.an.identifier=<b><code>{0}</code></b> is not a correct identifier to use in <b><code>{1}</code></b>
refactoring.is.not.supported.for.language={0} is not supported for {1}
rename.directory.command.name=Rename directory
rename.directories.command.name=Rename directories
target.destination.folder=Target &destination directory\:
move.method.is.not.supported.for.0=Move instance method is not supported for {0}
detecting.possible.conflicts=Detecting possible conflicts...
path.completion.shortcut=Use {0} for path completion

rename.project.action.title=Rename Project...
rename.project.handler.title=Rename &project
enter.new.project.name=Enter new project name:
rename.project=Rename Project
renames.project=Renames project
